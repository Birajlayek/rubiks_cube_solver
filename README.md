Project Report: Algorithmic Rubik's Cube SolverAuthor: Biraj LayekDate: May 2025Project Status: Completed1. Executive SummaryThis report documents the development of a high-performance Rubik's Cube (3x3) solver in C++. The project focused on the practical application and performance analysis of fundamental and advanced graph traversal algorithms. Three distinct class models were designed to represent the cube, allowing for a comparative study of data structure efficiency. The solver successfully implements Breadth-First Search (BFS), Depth-First Search (DFS), Iterative Deepening DFS (IDDFS), and Korf's Iterative Deepening A* (IDA*) algorithm. The implementation achieved remarkable efficiency, solving moderately scrambled cubes (8 moves) in under 3 seconds and complex configurations (13 moves) in under 10 seconds.2. Introduction & Project ObjectivesThe Rubik's Cube is a classic combinatorial puzzle that serves as an excellent case study for exploring search algorithms and computational complexity. The primary objective of this project was to move beyond theoretical knowledge and apply complex algorithms to solve a tangible problem, with a strong emphasis on performance and efficiency.The specific goals were:To Model the Rubik's Cube: Design and implement an accurate and efficient C++ representation of a 3x3 cube.To Compare Data Structures: Evaluate the performance implications of three different class models for the cube representation.To Implement Search Algorithms: Code and integrate multiple uninformed and informed search algorithms (BFS, DFS, IDDFS, IDA*).To Achieve High Performance: Optimize the implementation to solve scrambled cubes within strict time constraints.To Analyze Algorithmic Efficiency: Empirically measure and compare the solving times of different algorithms on puzzles of varying complexity.3. Technical Design and Algorithmic ImplementationThe core of the project was developed in C++ for its performance advantages and low-level control over memory management.Cube Representation:Three distinct C++ class models were designed to represent the state of the 3x3 cube. These models utilized different standard data structures (e.g., multi-dimensional arrays, std::vector) to evaluate trade-offs between memory usage, ease of manipulation (rotating faces), and overall performance.Search Algorithms Implemented:Breadth-First Search (BFS): A brute-force algorithm that guarantees the shortest solution path in terms of moves. It is memory-intensive but effective for cubes with a low number of scrambles.Depth-First Search (DFS): Explores as far as possible along each branch before backtracking. It is memory-efficient but does not guarantee the shortest solution.Iterative Deepening DFS (IDDFS): Combines the space-efficiency of DFS with the optimal solution guarantee of BFS by performing a series of depth-limited searches.Korf's IDA (Iterative Deepening A):** An informed search algorithm that uses a heuristic (e.g., pattern databases) to estimate the distance to the goal state. This significantly prunes the search space, allowing it to solve much more complex scrambles efficiently.4. Performance Results and Key AchievementsThe solver's performance was rigorously tested against cubes with varying scramble depths. The results highlight the efficiency of the C++ implementation and the effectiveness of the chosen algorithms.Benchmark 1: Moderate ComplexityScramble Depth: 8 movesAlgorithms: BFS, DFS, IDDFSResult: Achieved a consistent solving time of under 3 seconds. This demonstrates the efficiency of the core cube model and the basic search implementations.Benchmark 2: High ComplexityScramble Depth: 13 movesAlgorithm: Korf's IDA* AlgorithmResult: Achieved a high-performance solving time of under 10 seconds. This showcases the power of heuristic-based search in tackling a much larger state space where brute-force methods would fail.5. ConclusionThis project successfully translated theoretical computer science concepts into a practical, high-performance application. The development of the Rubik's Cube solver demonstrated a deep understanding of data structures, algorithmic design, and performance optimization in C++. The impressive solving times achieved are a direct result of efficient modeling and the correct application of advanced search algorithms like IDA*. The project serves as a strong testament to advanced problem-solving and software engineering capabilities.
